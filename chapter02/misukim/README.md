## 2. 렌더링
프레임워크 없이 DOM을 효과적으로 조작하는 방법을 배운다.

## 순수 함수 (Pure Function)
순수 함수를 사용하여 DOM에 요소를 렌더링하는 것은 일반적으로 렌더링 함수가 다음과 같다는 것을 의미한다.
* 특정 입력(속성이나 상태같은)을 받는다.
* 외부 상태나 변수를 변경하지 않고 UI의 설명(보통 가상 DOM 노드로)을 출력한다.
* React에서의 예제
    * React에서는 컴포넌트를 순수 함수로 작성할 수 있다.
    ```
    function HelloWorld(props) {
        return <h1>Hello, {props.name}!</h1>;
    }
    ```
    이 함수는 순수하다. 왜냐하면
    * props 입력에만 의존한다.
    * 동일한 props에 대해 항상 같은 출력을 렌더링한다.
    * 외부 상태나 변수를 변경하지 않는다.

    React에서 순수 함수 모델의 이점
    1. **재사용성**: 외부 상태에 의존하거나 수정하지 않기 때문에 순수 함수로 설계된 컴포넌트는 애플리케이션의 다른 부분이나 다른 애플리케이션에서 더 재사용하기 쉽다.
    2. **테스트 및 디버깅**: 순수 컴포넌트는 입력 props와 상태에서 출력을 예측할 수 있기 때문에 테스트하기가 더 쉽습니다. 외부 요인이나 부작용을 고려할 필요가 없다.
    3. **최적화**: React는 재렌더링을 최적화할 수 있다. props와 상태가 변경되지 않았다면, React는 컴포넌트의 재렌더링을 건너뛰고 이전 출력을 사용할 수 있습니다. 이러한 최적화는 React가 컴포넌트가 순수 함수처럼 행동할 것으로 기대하기 때문에 가능하다.
    
        **실제 고려 사항**

        순수 함수 모델이 이상적이긴 하지만, 실제 React 컴포넌트는 종종 데이터를 가져오기, API와 상호 작용하거나 직접적으로 브라우저 저장소를 조작하는 등의 부작용을 처리해야 한다. 이러한 특성은 순수 함수의 특성이 아니기 때문에 React는 다음과 같은 시나리오를 처리한다.
    * **훅** (ex. useEffect): 함수형 컴포넌트에서 부작용을 처리할 수 있게 하며, 클래스 컴포넌트가 생명주기 메서드를 사용하는 것과 유사하게 생명주기 이벤트와 부작용을 관리한다.
    * **고차 컴포넌트 및 컨텍스트** : 상태와 부작용을 관리하고 격리하는 방법을 제공하며, 주요 컴포넌트 함수를 가능한 한 순수하게 유지한다.


### 왜 순수 함수를 사용하는 방법이 있는가?

    JavaScript의 기본 함수 동작은 엄밀히 말해 함수형이 아닙니다/
    자바스크립트의 함수는 함수형 프로그래밍에서 장려하는 순수 함수와 달리 외부 상태에 따라 부작용을 일으킬 수 있습니다.
    그러나 JavaScript 개발자는 의도적으로 순수 함수를 작성하고 가능한 경우 부작용을 피함으로써 함수형 프로그래밍 원칙을 따르도록 선택할 수 있습니다.

### 순수 함수의 장점이 있음에도 항상 사용하지 않는 이유는?
 1. **부작용 처리**: 애플리케이션은 종종 외부 세계와의 상호작용(예: 파일 읽기/쓰기, 네트워크 요청, 데이터베이스 쿼리, DOM 조작)이 필요하며 이는 본질적으로 부작용을 포함합니다. 순수 함수는 이러한 작업을 직접 처리하지 않습니다.
2. **상태 관리**: 순수 함수 자체는 상태를 관리하지 않지만 많은 애플리케이션은 사용자 상호작용에 응답하거나 시간에 따라 데이터를 관리하는 등의 상태 관리 로직이 필요합니다. 이러한 기능을 순수 함수만을 사용하여 구현하는 것은 때때로 복잡성을 추가할 수 있으며, 추가 도구나 패턴(리듀서 사용 또는 명령 패턴 같은)이 필요합니다.
3. **성능 고려 사항**: 경우에 따라 부작용 또는 외부 상태를 피하는 것이 덜 효율적인 솔루션을 초래할 수 있습니다. 예를 들어, 순수 함수를 사용하면 기존 객체나 배열을 수정하는 대신 새 객체나 배열을 재생성해야 할 수 있으며, 이는 컨텍스트에 따라 메모리 사용이 더 많거나 느릴 수 있습니다.
4. **아키텍처 제약**: 일부 아키텍처 또는 프레임워크는 함수형 프로그래밍 원칙을 강조하지 않아 순수 함수의 구현이 직관적이거나 간단하지 않을 수 있습니다.

## 렌더링 함수
순수하게 함수를 사용해 요소를 DOM에 렌더링하는 다양한 방법을 분석한다.
순수 함수로 요소를 렌더링한다는 것은 DOM 요소가 애플리케이션의 상태에만 의존한다는 것을 의미한다.
* [TodoMVC][1] 템플릿을 예제로 사용 

### 예제 I : 순수 함수 렌더링 [코드 전체보기][2]
    첫번째 예제에서는 문자열을 사용해 요소를 렌더링한다.
첫번째 예제에서의 렌더링 방식은 requestAnimationFrame과 가상 노드 조작을 사용해 충분한 성능을 보여준다. 하지만 뷰 함수는 읽기 쉽지 않다. 코드는 두 가지 중요한 문제를 갖고 있다.
* **하나의 거대한 함수** : 여러 DOM을 조작하는 함수가 단 하나뿐이다. 이는 상황을 아주 쉽게 복잡하게 만들 수 있다.
* **동일한 작업을 수행하는 여러 방법** : 문자열을 통해 리스트 항목을 생성한다. todo count 요소의 경우 단순히 기존 요소에 테스트를 추가하기만 하면 된다. 필터의 경우 classList를 관리한다.

다음 예제에서는 뷰를 좀 더 작은 함수로 나누고 일관성 문제를 해결해보자.

### 예제 II [코드 전체보기][3]
    코드가 훨씬 나아졌다. 동일한 서명의 세 개의 개별 함수를 만들었다.
    이들 함수는 이 책에서 작성하는 '구성 요소 라이브러리'의 첫 번째 초안이 된다.

앱 뷰(app.js)의 코드를 확인해보면 올바른 함수를 수동으로 호출해야 한다는 것을 알 수 있다. 구성 요소 기반의 애플리케이션을 작성하려면 구성 요소간의 상호작용에 선언적 방식을 사용해야 한다. 시스템은 모든 부분을 자동으로 연결할 것이다.

### 예제 III : 구성 요소 함수 [코드 전체보기][4]
    이번 코드는 구성 요소 레지스트리를 갖는 렌더링 엔진의 예다.
    이 목표를 달성하고자 먼저 해야 할 일은 특정 사례에서 사용할 구성 요소를 선언하는 방법을 정의하는 것이다.
    예제에서는 todos, counters, filters의 세 가지 구성 요소를 가진다.
이번 예제에서는<br>
1. html 파일에 데이터 속성을 적용. 구성 요소를 data-component 속성에 넣고 레지스트리 키와 일치하도록 적용
2. 레지스트리에 구성 요소 추가를 위해 레지스트리 접근자 메소드 생성 (예제에서 만든 add 메소드 참고)
3. index.js에서 모든 요소를 혼합하는 컨트롤러 생성. 여기서 구성 요소 레지스트리를 사용할 수 있다.

이렇게 첫번째 구성 요소 기반 애플리케이션을 프레임워크 없이 작성했다.<br>
아래 그림에서 애플리케이션의 기본 스키마를 확인할 수 있다.<br>

![2-8](https://github.com/BeyondPong/Frontend_Study/assets/26542114/97356037-2e44-4b24-921a-9039ac24e528)

### 예제 IV : 동적 데이터 렌더링 [코드 전체보기][5]
    이전 예제에서는 정적 데이터를 사용했다.
    그러나 실제 애플리케이션에서는 사용자나 시스템의 이벤트에 의해 데이터가 변경된다.
    index.js와 같이 5초마다 상태를 무작위로 변경해보자.
#### 가상 DOM
리액트에 의해 유명해진 가상 DOM 개념은 선언적 렌더링 엔진의 성능을 개선시키는 방법이다. UI 표현은 메모리에 유지되고 '실제' DOM과 동기화된다. 실제 DOM은 가능한 적은 작업을 수행한다. 이 과정은 조정(reconciliation)이라고 불린다. 
이전 알고리즘에서는 전체 ul을 교체했다. 가상 DOM의 핵심은 diff 알고리즘이다. 이 알고리즘은 실제 DOM을 문서에서 분리된(즉, 가상의) 새로운 DOM 요소의 사본으로 바꾸는 가장 빠른 방법을 찾아낸다.
아래 그림은 이 메커니즘을 시각적으로 보여준다.<br>

![2-9](https://user-images.githubusercontent.com/66112716/212852347-6aac6f35-2667-488e-b6ee-fac4e56c9998.png)

다음 예제에서 간단한 가상 DOM 구현을 해보자.

### 예제 V : 간단한 가상 DOM 구현 [코드 전체보기][6]
    메인 컨트롤러에서 replaceWith 대신 사용할 아주 간단한 diff 알고리즘을 사용해보자.
    이 알고리즘은 "실제" DOM 트리(브라우저에 렌더링되는 내용)와 "가상" DOM 트리(Javascript 표현)를 비교하고 실제 DOM에 필요한 변경사항만 적용한다.
    이를 통해 DOM 조작을 최소화하여 성능을 최적화한다.
applyDiff 함수 매개변수는 parentNode, realNode, virtualNode로
realNode와 virtualNode를 비교하여 차이점을 찾고 재귀적으로 아래 작업을 수행한다.
* realNode가 존재하지만 virtualNode가 없으면 parentNode에서 realNode를 제거한다.
* realNode가 없지만 virtualNode가 있으면 parentNode에 virtualNode를 추가한다.
* 두 Node가 모두 있으면 차이를 확인하여 realNode를 virtualNode로 교체할지, 속성을 업데이트하고 자식을 재귀적으로 비교할지를 결정한다.


isNodeChanged 함수를 통해 두 Node간의 차이를 확인한다.
* 속성 수가 다르다.
* 하나 이상의 속성이 변경됐다.
* 노드에는 자식이 없으며, textContent가 다르다.

### 요약
    2장에서는 프레임워크 없이 애플리케이션의 렌더링 엔진을 만드는 방법을 배웠다.
    또한 간단한 구성 요소 레지스트리 작성 방법과 가상 DOM 알고리즘을 사용해 엔진 성능을 향상시키는 방법도 살펴봤다.
    3장에서는 사용자 에빈트를 관리하는 방법과 이런 이벤트를 렌더링 엔진과 통합하는 방법을 알아본다.

[1]: https://todomvc.com/
[2]: https://github.com/BeyondPong/Frontend_Study/tree/main/chapter02/misukim/01
[3]: https://github.com/BeyondPong/Frontend_Study/tree/main/chapter02/misukim/02
[4]: https://github.com/BeyondPong/Frontend_Study/tree/main/chapter02/misukim/03
[5]: https://github.com/BeyondPong/Frontend_Study/tree/main/chapter02/misukim/04
[6]: https://github.com/BeyondPong/Frontend_Study/tree/main/chapter02/misukim/05